# 1. Introduction to Flows

You should now have Completed the Following things:

1. Importing implemented Artefacts
2. Implement Wizard Step 1 (Part1)

Next you will complete the implementation of the first step of the wizard.

# 2. Implementation Task

## Introduction

We will now replace the notification with code to persist the changes in dataverse. We will use a different approaches for new and edit:
* Edit: We will use the standard `SubmitForm` command
* New: We will implement an embedded flow.

The reason for the embedded flow is a limitation of the `SubmitForm` command when creatng a new record. So far no simple built-in way exists to retrieve the values of the newly created record. This is a problem because in our case the primary key of the record is autogenerated. That means we cannot infer the record from the user input. The only known workaround would be to use all other columns as combined key to guarantee uniqueness. The embedded workflow gives us a chance to write the record AND to retrieve all values including the autogenerated primary key for the subsequent upload. Moreover it is the perfect opportunity to play with PowerAutomate hands-on.

## Define Flow

To create an embedded flow click on the power automate icon `>>` and then click `+ Add flow` as shown below:
<br><img src="./images/flow_new_trigger_create.png" /><br>

Clicking on `Create from blank` takes you to the flow designer:
<br><img src="./images/flow_new_create.png" /><br>

In the designer you normally just see the initial step. The second step in the screesnhot just serves as illustration for the scenarios that can hit you.
<br><img src="./images/flow_new_designer_ovr.png" /><br>

The following general rules apply:
* To add an action at the end click on the button `New step`
* To expand a step do a left mouse single click on the step
* To insert a step between two existing ones click on the plus symbol between the steps
* Clicking the `Flow Checker` informs you about errors
* To delete a step click on the three dots right to the header. There you find an entry for removal.
* Saving the flow requires a name. Click on the text `Untitled` and enter your desired name. Afterwards press the save button.

In the next step we have to get the internal ID of the record holding the importing user. We will use the `List Rows` action within dataverse for that. Click `New Step` and enter `dataverse` in the search field as shown below:

<br><img src="./images/flow_new_search_action.png" /><br>

Pick the action `List rows`. The screenshot below shows the added action:

<br><img src="./images/flow_new_list_rows.png" /><br>

Set the fields as shown in the table:
|Field           |Value                      |
|----------------|---------------------------|
| Table name     | IMP_USERS                 |
| Row count      | 1                         |

The expression for `Filter rows` we use for filtering the rows by the importing username that was specified in the form. The required expression is `hackpp_sceapp_cst_username eq '<value from form>'`. 
`hackpp_sceapp_cst_username` is the so called `EntitySetName` of the targeted table. 
To poulate `<value from form>` we have to generate a new parameter. The screenshot below shows how that is done. Position the cursor in the parentheses and click in the field. Select in the tab `Dynamic Content` the expression `Ask in PowerApps`. The screenshot shows the reaction of the designer after `Ask in PowerApps` was picked.
<br><img src="./images/flow_new_list_rows_add_para.png" /><br>

When you hover over the generated expression you see the name of the expected parameter which is `Listrows_Filterrows` (Corresponds to `<name of action>_<name of field>`).

In the next step we will add a new row that represents our import header. We will use the `Add a new row` action within dataverse. Click `New Step` and enter `dataverse` in the search field. Pick the action `List rows`. The screenshot below shows the action. Select `IMP_CO2_CONS_RAW_HDR` as table name. As a result the table specific columns will be shown as illustrated in the screenshot below. Mandatory fields are marked with an asteriks. The generated UI is not correct reagrding `CST_IMP_CODE`. Yes as logical primary key it is mandatory. However due to the auto generated definition no value is required. We will provide a special dummy to satisfy the constraints:
<br><img src="./images/flow_new_add_row.png" /><br>

As a first value we will set the value for CST_IMP_USERNAMES. Power Platform expects an expression `<EntitySetName>(<GUID of record>)>`. The entity set name in our case is `hackpp_sceapp_imp_users` and `<GUID of record>` is the result of the previous action. Enter `hackpp_sceapp_imp_users()` and position the mouse cursor into the parentheses. Power Platform will assist you in completing the dynamic expression needed here. Pick `IMP_USR` from the displayed options in the tab `Dynamic content` as shown in the screenshot.
<br><img src="./images/flow_new_set_imp_user.png" /><br>

When you selected the value you will notice a change, Dataverse embeds the new `Add new row` task in a loop since the previous command might return multiple rows. The screenshot below shows this new situation:
<br><img src="./images/flow_new_apply_each.png" /><br>

Let's try to understand `Apply to each` better. The major input is the output from the previous step displayed as ` value x`. To understand it you have to be aware of the JSON structure that is returned by `List rows`. Below you find a sample:
```
{
	"@odata.context": "https://orgc9bd3046.crm6.dynamics.com/api/data/v9.1/$metadata#cr953_workflowmaxes(cr953_jobid,cr953_...)",
	"@Microsoft.Dynamics.CRM.totalrecordcount": -1,
	"@Microsoft.Dynamics.CRM.totalrecordcountlimitexceeded": false,
	"value": [{
		"@odata.type": "#Microsoft.Dynamics.CRM.cst_users",
		"@odata.id": "https://domain.crm6.dynamics.com/api/data/v9.1/cst_users(cf5033a4-c9c8-eb11-bacc-00224817f...)",
		"hackpp_sceapp_imp_userid": "cf5033a4-c9c8-eb11-bacc-00154817f386"
    ...
	}]
}
```
The used path `body/value` is another word for navigating to the `value` property. As you can see in the JSON the property `value` is an array. The loop now cycles over each entry. We need the id which is shown as `IMP_USER x`. With the expression `items('Apply_to_each')?['hackpp_sceapp_imp_userid']` we pick the technical id we are interested in.

Expand the `Add new row` action again to set now the remaining fields. For setting `CST_IMP_TS` we use the built-in function `utcNow`. As you can see in the screenshot we are in the tab `Expression`. Enter it as formula in the bar as shown below:
<br><img src="./images/flow_new_add_row_ts_utcnow.png" /><br>

Follow the instructions in the table for the remaining fields:
|Field           |Value                                         |
|----------------|----------------------------------------------|
| CST_IMP_CODE   | Set the field to the special expression `null` as you did it for `utcNow`. Otherwise you get an error.     |
| CST_IMP_YEAR   | Use the way for adding a parameter as before |
| CST_IMP_DESC   | Use the way for adding a parameter as before |
| CST_IMP_STATE  | Select Pending from the dropdown             |

When you have filled out everything your action should like the following:

<br><img src="./images/flow_new_row_final.png" /><br>

As a last step we now have to return the primary key of the newly created record. Enter `PowerApp` as category and add a new action `Respond to a PowerApp or flow`. In the beginning the task is empty and we have to create a return parameter by clicking on `Add an output`. Click on the button and select `Text`. You will then get the fields for a new named output as shown below:

<br><img src="./images/flow_new_output_def_ret.png" /><br>

Enter `returnedval` as name for the parameter. Click into the value field and let Power Platform assist you as shown in the screenshot below. The column with the primary key is named `CST_IMP_CODE`:

<br><img src="./images/flow_new_output_val.png" /><br>

Save your flow under the new name you want. Before you leave the designer note the name of the flow you have defined. You will need it in the next step.

## Wire Flow with Submit Button

The following steps are necessary to add your flow:
* Add the new flow to your application
* Call your flow when Submit Button clicked

**Regarding add flow)**

Click on the power automate icon and click the button `Add flow`. Enter the name under which you saved the flow.

**Cally our flow)**

We will replace now the original content of the `OnSelect`property from the previous step. We plan for different ways to persist the changes. In the edit case we can use the standard `SubmitForm` to persist the changes. We just add a confirmation message for the user. For new we have run our flow and store returned value for later processing in a local variable. The user is also informed with an additional message. Enter the following formula in the property `OnSelect` that is doing all that:
```
If(locImpMode = "New", 
   UpdateContext(
	{locParaUserName: WizardStepImpHdrMainViewImportUserNameDropDown.Selected.CST_USERNAME,
	 locParaYear: WizardStepImpHdrMainViewImportYearTextBox.Text,
	 locParaDesc: WizardStepImpHdrMainViewImportDescTextBox.Value});
   UpdateContext(
	 {locNewImpCode: TestFlowInp.Run(locParaUserName, locParaYear, locParaDesc).returnedval });
   Notify("Import " & locNewImpCode & " has been created."), 
   SubmitForm(WizardStepImpHdrMainView);
   Notify("Import " & WizardStepImpHdrMainView.LastSubmit.CST_IMP_CODE & " has been updated."))
```
The important new takeaways from that code are:
* Multiple expressions

  No special block identifiers as curly brackets in C are required to run multiple commands. Commands are just separated by semikolon.

* If expression

  The generic form of the if is `if(<test cond>, <expressions to run if true>, <expressions to run if false>). In our case the expressions for the if and the true case are just a bit longer.

* UpdateContext

  Sets the local variables (scoped per screen) to the values specified in curly brackets.

* Calling the flow

  Running a flow with parameters requires the run command as follows: `<flowname>.Run(<parameters separated by comma>)`. Referencing the return value is done by `.<name of return parameter>`.

* LastSubmit: Refers to the stored data. Unfortunately it only works for edit only.

# 3. Testing changes

Start from the import overview page to ensure a correct screen context. Press the play button after selecting the overview screen to start the tests. Thanks to your changes the following scenarios should now work:
|Test                                             |Expected Result          ,                |
|-------------------------------------------------|------------------------------------------|
|Wizard first step: Click on Submit button (new)  |You should see a new record in the dataverse table after clicking submit. The displayed message should be accordingly.|
|Wizard first step: Click on Submit button (edit) |You should see the updated record in the dataverse table. The displayed message should be accordingly.|

